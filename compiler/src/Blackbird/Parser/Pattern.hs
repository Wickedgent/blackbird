{-# LANGUAGE TupleSections #-}
{-# LANGUAGE OverloadedStrings #-}
--------------------------------------------------------------------
-- |
-- Copyright :  (c) Edward Kmett and Dan Doel 2013
-- License   :  BSD2
-- Maintainer:  Qredo LTD <support@qredo.com>
-- Stability :  experimental
-- Portability: non-portable
--
-- This module provides the parser for terms
--------------------------------------------------------------------
module Blackbird.Parser.Pattern
  ( validate
  , pattern
  , pattern0
  , pattern1
  , PP
  ) where

import Control.Applicative
import Control.Lens hiding (op)
import Data.Foldable as Foldable
import Data.Text (Text)
import Data.Void
import qualified Data.Set as Set
import Blackbird.Builtin.Global
import Blackbird.Builtin.Pattern
import Blackbird.Builtin.Type (anyType)
import Blackbird.Parser.Literal
import Blackbird.Parser.Style
import Blackbird.Parser.Trifecta (brackets, parens)
import Blackbird.Parser.Type
import Blackbird.Syntax
import Text.Parser.Combinators
import Text.Parser.Token (TokenParsing, commaSep, reserve, symbol)

-- | Check a 'Binder' for linearity.
--
-- Each variable name must be used at most once in the pattern.
validate :: (Monad m, Ord v) => Binder v a -> (v -> m Void) -> m ()
validate b e =
  () <$ foldlM (\s n -> if n `Set.member` s then vacuous $ e n else return $ Set.insert n s)
               Set.empty
               (vars b)

-- | The simple pattern type generated by pattern parsing.
type PP = P Ann Text

varP :: (Monad m, TokenParsing m) => m PP
varP = termIdentifier <&> sigp ?? anyType

-- | Parse a single pattern part (e.g. an argument to a lambda)
pattern0 :: (MonadFail m, TokenParsing m) => m PP
pattern0
   = conp nothingg [] <$ symbol "Nothing"
 <|> varP
 <|> strictp <$ symbol "!" <*> pattern0
 <|> _p <$ symbol "_"
 <|> litp <$> literal
 <|> parens (tup' <$> patterns)
 <|> brackets (makeList <$> patterns)
 where
 makeList []     = conp nilg  []
 makeList (x:xs) = conp consg [x,makeList xs]

sigP :: (MonadFail m, TokenParsing m) => m PP
sigP = sigp <$> try (termIdentifier <* reserve op ":") <*> annotation

-- TODO: remove this when constructor patterns really work.
eP, longhP, justP, nothingP :: (MonadFail m, TokenParsing m) => m PP
eP       = conp eg       <$ symbol "E"       <*> many pattern1
justP    = conp justg    <$ symbol "Just"    <*> many pattern1
nothingP = conp nothingg <$ symbol "Nothing" <*> many pattern1
longhP   = conp longhg   <$ symbol "Long#"   <*> many pattern1

-- as patterns
pattern1 :: (MonadFail m, TokenParsing m) => m PP
pattern1
    = asp <$> try (termIdentifier <* symbol "@") <*> pattern1
  <|> pattern0

-- | Parse a single pattern (e.g. a case statement alt pattern)
pattern2 :: (MonadFail m, TokenParsing m) => m PP
pattern2
    = eP
  <|> justP
  <|> nothingP
  <|> longhP
  <|> pattern1

pattern3 :: (MonadFail m, TokenParsing m) => m PP
pattern3 = sepByNonEmpty pattern2 (symbol "::") <&>
  foldr1 (\x xs -> conp consg [x,xs])

-- existentials sigP
pattern4 :: (MonadFail m, TokenParsing m) => m PP
pattern4
   = sigP
 <|> pattern3

patterns :: (MonadFail m, TokenParsing m) => m [PP]
patterns = commaSep pattern4

-- | Parse a single pattern (e.g. a case statement alt pattern)
pattern :: (MonadFail m, TokenParsing m) => m PP
pattern = pattern3
